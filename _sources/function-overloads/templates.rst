..  Copyright (C)  Dave Parillo.  Permission is granted to copy, distribute
    and/or modify this document under the terms of the GNU Free Documentation
    License, Version 1.3 or any later version published by the Free Software
    Foundation; with Invariant Sections being Forward, and Preface,
    no Front-Cover Texts, and no Back-Cover Texts.  A copy of
    the license is included in the section entitled "GNU Free Documentation
    License".

.. index:: 
   single: function templates
   pair: templates; function

Function Templates
==================

Function overloads allow programmers with the same name,
that may or may not do the same thing.

What if our functions actually are intended to do exactly the same thing,
but merely on different types?

Function overloads allow us to write functions with the same names and different
parameter lists, but each function still requires its own function body,
even if it's only to call another function.

These two overloads each add their parameters, only on different types:

.. activecode:: ac-sum-without-templates
   :language: cpp

   #include <iostream>

   int sum (int a, int b) {
     return a+b;
   }

   double sum (double a, double b) {
     return a+b;
   }

   int main () {
     std::cout << sum (10,20) << '\n';
     std::cout << sum (1.0,1.5) << '\n';
   }

C++ provides a way to write a single piece of code
that can stand in for an entire *class of functions* that all
do exactly the same thing.

In C++, we can define a **template** for a function.
The template defines a *function generating recipe* 
using a *generic type* as a placeholder.
Templates are created using the ``template`` keyword, 
followed by template parameters in angle brackets ``<>``.
For example:

.. code-block:: cpp

   template <template-parameters> function-declaration 

Using templates, our previous sum functions collapse down to

.. activecode:: ac-sum-with-templates
   :language: cpp

   #include <iostream>

   template <class T> T sum (T a, T b) {  
     return a+b;
   }

   int main () {
     std::cout << sum (10,20) << '\n';
     std::cout << sum (1.0,1.5) << '\n';
   }

When identifying template parameter types,
it is common to see either ``typedef`` or ``class``.
As we will see later, a ``class`` defines a type definition,
so for the purposes of a template, they are effectively synonymous.
Whether you use 'typedef' or 'class' is a matter of preference.

The identifier ``T`` is traditional,
but any valid variable name could be used.
In introductory template tutorials ``AnyType`` is not uncommon.

Templates are completely specified in header files normally.
Because templates are neither declarations, nor definitions,
it is an error to write a template in a cpp source file and then
try to use it in another source file.

Using templated functions
-------------------------

In short, using functions generated by templates is
not very different from a non-templated function.


You can explicitly provide the type:

.. code-block:: cpp

   int main () {
     std::cout << sum<int> (10,20) << '\n';
     std::cout << sum<double> (1.0,1.5) << '\n';
 
     // or let the compiler deduce the type
     std::cout << sum (10,20) << '\n';
     std::cout << sum (1.0,1.5) << '\n';
   }


Multiple template parameters
----------------------------

A ``sum`` function that only adds numbers of the same type is not particularly useful.
Templates also allow defining multiple types to be used in a template
with each parameter having potentially a different type.

.. code-block:: cpp

   #include <iostream>

   template <class T1, class T2>
   bool are_equal (const T1& a, const T2& b) {
     return (a==b);
   }

   int main () {
     if (are_equal(10,10.0)) {
       std::cout << "x and y are equal\n";
     } else {
       std::cout << "x and y are not equal\n";
     }
   }

There is no 'rule' that says each template parameter can be used only once
in the function declaration.
You are also free to use a template parameter to define a local variable.



Non-generic template parameters
-------------------------------

Not every template parameter has to be a class or a typedef.
Any specific type is a valid template parameter.

The following example defines a template
that defines a function that multiplies 
a value of type ``T`` by a provided ``int N``.
The template parameter ``int N`` can be used in the function body
just like any other local variable or function parameter.

Non-generic template parameters may be specified as 
``const`` if the function
body will not modify them.

.. code-block:: cpp

  #include <iostream>

  // it is possible to forward declare a template
  template <class T, const int N> 
  T multiply (const T& val);

  int main() {
    std::cout << multiply<double,2>(3.14159) << '\n';
    std::cout << multiply<long,3>(10) << '\n';
  }

  // note the definition includes ALL of the declaration
  // including the template information
  template <class T, int N> 
  T multiply (const T& val) {
    return val * N;
  }



-----

.. admonition:: More to Explore

   TBD


