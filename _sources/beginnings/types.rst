..  Copyright (C)  Dave Parillo.  Permission is granted to copy, distribute
    and/or modify this document under the terms of the GNU Free Documentation
    License, Version 1.3 or any later version published by the Free Software
    Foundation; with Invariant Sections being Forward, and Preface,
    no Front-Cover Texts, and no Back-Cover Texts.  A copy of
    the license is included in the section entitled "GNU Free Documentation
    License".

.. include:: <isonum.txt>

.. index:: 
   pair: introductory topics; types
   pair: fundamental types; abstraction

Types
=====

In C++, objects, references, functions, and expressions all have a property called *type*, 
which both restricts the operations that are permitted for those entities 
and provides semantic meaning to the otherwise generic sequences of bits.


A :term:`type` is a collection of values.
For example, the Boolean type consists of the values ``true`` and
``false``.
The integers also form a type.
An integer is a :term:`simple type`
because its values contain no subparts.
A bank account object will typically contain several pieces of
information such as name, address, account number, and account
balance.

The C++ type system consists of the following types:

- Fundamental types

  - The type ``void``
  - The type ``nullptr_t``
  - Arithmetic types

    - Floating point types (``float``, ``double``, and ``long double``)
    - Integral types

      - The ``bool`` type (true & false)
      - The character types:

        - narrow character types (``char``, ``signed char``, ``unsigned char``)
        - wide character types (``char16_t``, ``char32_t``, ``wchar_t``)

      - signed integer types (``short int``, ``int``, ``long int``, ``long long int``)
      - unsigned integer types (``unsigned short int``, ``unsigned int``, ``unsigned long int``, ``unsigned long long int``)

- Compound types

  - Array types
  - Pointer types
  - Reference types
  - Function types
  - Class types
  - Enumeration types

Fundamental representations
---------------------------

Machines view stored data as sequences of bits that
can be manipulated by specific instructions.
These instructions include shifts, logical operations,
integer and floating arithmetic and more.
While machines manipulate these bit sequences efficiently, 
people do not.

High level languages introduce 
:term:`abstractions <abstraction>` to simplify
working with data.
Abstractions allow the data stored in memory to be managed
not as a sequence of bits, but as an integer,
a floating point number, a boolean, a character, or something else.
In C++, the abstractions for the built in numeric types
(plus the types ``void`` and ``nullptr_t``) 
are referred to as :term:`fundamental types <fundamental type>`.

It is natural to think that the types defined for the computer
are the same used in mathematics.
That assumption would be incorrect.
It is important to understand that all of the numeric types
are *abstractions*, that is they are approximations of the 
basic concepts learned in school.

What exactly do we mean?
The unsigned integer type represents the set of whole numbers.
In mathematics, this set is infinite:
given any number :math:`N` a new integer
:math:`M` can be generated by simply setting :math:`M = N + 1`.
However, this basic axiom does not apply to integers stored on a computer
because and integer on a computer occupies a fixed size: that is, an ``unsigned`` is stored
in a finite number of bits.
Another way to say this is that every numeric fundamental type has both a 
minimum and maximum allowed value.
This situation is very different from what you are used to in math class.

One consequence of a fixed size is that basic axioms of
mathematics are not always true.
For example, the ordinary associative law of addition:

.. math::

   (x + y) + z = x + (y + z)

is satisfied only if both :math:`|x + y| <= max int` and
:math:`|y + z| <= max int`.

In practice, the upper limit of an ``unsigned`` is so large that it
is not a limiting factor in many ordinary numeric calculations.
When the upper limit is exceeded, the results are typically dramatic.
:term:`Overflow <overflow>` errors are typically obvious.
Overflow errors may be more common when the type chosen is too small
for its intended purpose.

A slightly more involved example is the problem of how to represent signed integers.
In mathematics, negative numbers are represented by prefixing them with a minus ("−") sign.
However, on a computer, there are only bit sequences.
Once again, programmers are faced with the problem of abstraction.
What is the 'best' way to represent a signed integer that is both efficient and unambiguous?

As it turns out, there is no 'best' way.  
In fact, are many ways to solve this problem.
They all have their own trade-offs, but over time,
three commonly used representations have been used:

- Sign and magnitude
- One's complement
- Two's complement

While the :term:`two's complement` representation is now nearly universal,
this was not always the case.
In fact, during the 60's and 70's, debates raged about the best number format representations.

Sign and magnitude
..................

Arguably the easiest to understand as the representation is very similar to how
signed numbers are represented in mathematics.
The number's sign is stored in a *sign bit*: 
setting that bit (often the most significant bit) to 0 means a positive number or positive zero, 
and setting it to 1 is for a negative number or negative zero. 
The remaining bits in the number indicate the magnitude (or absolute value). 

In eight bits the magnitude can range from ``0000000`` (0) to ``1111111`` (127). 
Numbers ranging from −127 to +127 can be represented once the sign bit (the eighth bit) is added. 
For example, −43 encoded in an eight-bit byte is ``10101011`` while 43 is ``00101011``. 
A consequence of using signed magnitude representation is that there are two ways to represent zero, 
``00000000`` (0) and ``10000000`` (−0).

Some early binary computers (e.g., IBM 7090) use this representation for integers,
perhaps because of its natural relation to common usage. 
However, it is slower and requires more complicated hardware than
one's complement or two's complement representations.
Signed magnitude remains the most common way of representing the exponent in floating point values.
It is the official IEEE floating point number format.

The important item here is that even today, 
floating point numbers have two different representations for ``0``, 
a side effect of the sign and magnitude representation.

The following C program [Aspnes2014]_ prints the sign, exponent and mantissa
of a few small numbers.

.. activecode:: ac_floats_2
   :language: c

   #include <stdio.h>
   #include <math.h>
   #include <values.h>

   /* endianness testing */
   const int EndianTest = 0x04030201;

   #define LITTLE_ENDIAN() (*((const char *) &EndianTest) == 0x01)

   /* extract nth LSB from object stored in lvalue x */
   #define GET_BIT(x, n) ((((const char *) &x)[LITTLE_ENDIAN() ?\
             (n) / CHARBITS :\
             sizeof(x) - (n) / CHARBITS - 1] >> ((n) % CHARBITS)) & 0x01)

   #define PUT_BIT(x, n) (putchar(GET_BIT((x), (n)) ? '1' : '0'))

   void print_float_bits(float f) {
     int i;

     i = FLOATBITS - 1;
     PUT_BIT(f, i);
     putchar(' ');
     for(i--; i >= 23; i--) {
       PUT_BIT(f, i);
     }
     putchar(' ');
     for(; i >= 0; i--) {
       PUT_BIT(f, i);
     }
   }

   void print_float(float f) {
     printf("%2g = ", f);
     print_float_bits(f);
     putchar('\n');
   }

   int main(int argc, char** argv) {
     float u = -1.0;
     float v = u * 0.0;
     float w = v * -1.0;
     puts(" x = S   exp     mantissa");
     print_float(u);
     print_float(v);
     print_float(w);
     print_float(1.0);
     print_float(2.0);
     print_float(3.0);
     print_float(6.0);
     print_float(8.0);
     print_float(13.0);
     print_float(21.0);
   }


One's complement
................

Alternatively, a system known as ones' complement can be used to represent negative numbers. 
The ones' complement form of a negative binary number is the bitwise NOT applied to each bit in the number. 
That is, each negative number is the "complement" of its positive counterpart. 

C++ provides a complement operator ``~`` for this purpose.
The complement of the 5 bit binary number ``11100``, is ``00011``, which is the number 3.

Note that like sign-and-magnitude representation, ones' complement has two representations 
of 0: ``00000000`` (+0) and ``11111111`` (−0).

A few of the 4 bit one's complement integers are:

======= ==== ==== ==== ==== ==== ==== ==== ====
Decimal -7   -2   -1   -0   0    1    2    7  
======= ==== ==== ==== ==== ==== ==== ==== ====
Binary  1000 1101 1110 1111 0000 0001 0010 0111 
======= ==== ==== ==== ==== ==== ==== ==== ====

One's complement is important both historically, and because it is used to generate
two's complement numbers.
No modern computers store one's complement signed integers.

Two's complement
................

A variation of one's complement that avoids the "two zeroes problem" is two's complement.
In two's complement, negative numbers are represented by the bit pattern which is one 
greater (in an unsigned sense) than the one's complement of the positive value.
A short 3 bit table comparing one's and two's complement looks like this:

================ ==== ==== ==== ==== ==== ==== ==== ====
3-bit pattern    100  101  110  111  000  001  010  011
================ ==== ==== ==== ==== ==== ==== ==== ====
One's complement -3   -2   -1   -0   0    1    2    3
Two's complement -4   -3   -2   -1   0    1    2    3
Unsigned value   4    5    6    7    0    1    2    3
================ ==== ==== ==== ==== ==== ==== ==== ====

Negating a number is done by inverting all the bits
(in other words taking the one's complement) 
and then adding one to that result.

Virtually all modern computers store signed integer values using the
two's complement representation.
The following program demonstrates the consistency of the two's
complement representation.

.. activecode:: ac_two_comp_1
   :language: cpp

   #include <bitset>
   #include <iostream>
   using std::cout;
   using std::bitset;
 
   int main() {
     int x = -1;
     int y = ~x;  // one's complement of x
     int z = x * 0;
 
     cout << "x: " << x << "\t(" << bitset<4>(x) << ")\n";
     cout << "y: " << y << "\t(" << bitset<4>(y) << ")\n";
     cout << "z: " << z << "\t(" << bitset<4>(z) << ")\n";
     cout << "~z: " << ~z << "\t(" << bitset<4>(~z) << ")\n";
   }

Overflow
.........

Why bother with all this obscure discussion about type representation now?
Because it is very useful to know how numbers are actually stored when debugging your code.
Sometimes a value cannot be represented in the limited number
of bits allowed.   Examples::

    unsigned, 3 bits:    8 would require at least 4 bits (1000)
    sign mag., 4 bits:   8 would require at least 5 bits (01000)


When a value cannot be represented in the number of bits allowed,
we say that :term:`overflow` has occurred.  
Overflow occurs when doing arithmetic operations.

.. code-block:: text

   example:          3 bit unsigned representation

     011 (3)
   + 110 (6)
   ---------
      ?  (9)     it would require 4 bits (1001) to represent
                 the value 9 in unsigned rep.


Mistakes happen.
Someday, you will write some code that will overflow the amount
of space allocated for the type.
It helps to understand what is going on if you recognize what overflow looks like for various types.

.. activecode:: ac_types_2
   :language: cpp

   #include <iostream>

   int main() {
     int8_t x = 128;
     int8_t y = 1;

     std::cout << "x + y = " << (x + y) << '\n';
   }

Overflow involving signed integral types overflows into the most significant bit,
effectively changing the sign, as in the preceding example.
Unsigned integers do not, technically, overflow in that they do not become negative.
They are after all, unsigned.
They **do** however still 'wrap around' and the result can be that adding
two values can result in a value smaller than the sum of the two values.

.. admonition:: Try This!

   Copy the preceding program to your own development environment and 
   change the types from ``int8_t`` to ``uint8_t``.

   Change the value of ``x`` to 256 and run the program.

   What do you expect to see? What did you see?

   
Preventing overflow errors
~~~~~~~~~~~~~~~~~~~~~~~~~~

The C and C++ compilers do not check math overflow for you.
They can report when it happens at runtime, but by that point,
the error has already occurred.
It is generally preferred to check for possible overflow before
attempting a calculation that might overflow.

The following program checks for addition overflow and throws an error
if addition overflow would occur.

.. code-block:: cpp

   #include <iostream>
   #include <limits>
   #include <string>

   int main () {
     int x = std::numeric_limits<int>::max();
     int y = x - 9;

     if (std::numeric_limits<int>::max() - x < y) {
       std::cerr << "addition failed: result is too big\n";
     } else {
       // addition is safe
       std::cout << "x+y = " << (x+y) << '\n';
     }

   }

Similarly, checks for multiplication overflow and exponentiation overflow
could use the following checks:

.. code-block:: cpp

   if (std::numeric_limits<int>::max() / x < y) {
    std::cerr << "multiplication failed: result is too big\n";
   }

   // number of bits in uint32_t
   const num_bits = 32;
   if (log2(base)*exponent > sizeof(uint32_t) * num_bits) {
     std::cerr << "exponentiation failed: result is too big\n";
   }

.. topic:: Other operations

   We haven't discussed overflow for subtraction and division.

   Do we have to worry about overflow for these two operations?

   Why or why not?

Compound types
--------------

Most of the compound types will be covered in greater detail later in this book.
Those that aren't covered later are discussed now.

Array types
...........

An **array** is a block of memory that holds one or more objects of a given type. 
Declare an array by giving the type of object the array holds followed by 
the array name and the size in square brackets:

.. code-block:: cpp

   int a[3];              // array of 3 ints
   int b[3] = {4, 5, 6};  // array of 3 ints
   int c[]  = {1, 2, 3};  // array of 3 ints
   char name[64];         // array of 64 characters

Arrays **can** be constructed from any fundamental type, pointers, pointers to members, 
classes, enumerations, or from other arrays (in which case the array is said to be multi-dimensional). 
Arrays **cannot** be constructed from references, functions, or abstract class types.

Objects of array type cannot be modified as a whole: 
even though they are lvalues (e.g. an address of array can be taken), 
they cannot appear on the left hand side of an assignment operator

.. code-block:: cpp

   int a[3] = {4, 5, 6};  // array of 3 ints
   int (*b)[3] = &a;      // OK to make an array of pointers using an address
   int c[3];
   c = a;                 // Error. Can't assign to an array
   c[0] = a[0];           // OK.

Reference types
...............

A :term:`reference` type
declares a named variable as an alias to an *already-existing* object or function.

References are a C++ addition - one of the few types not present in C.

A reference is required to be initialized to refer to a valid object or function.
There are no references to ``void`` and no references to references.

.. code-block:: cpp
   
   int a = 3;
   int& r1 = a; // r1 is a reference to a
   r1 = 72;     // changes the value of a
   int& r2;     // Error. r2 must refer to something

Once initialized, a reference always refers to the same object.
The value of the object may change, but the address referred to may not.

.. note::

   C++ 11 introduced a new kind of reference, an *rvalue reference*.
   We will cover this when we get into classes.
   All of the references discussed until then will be *lvalue references*.


The type ``std::size_t``
------------------------

There exists an implementation defined ``typedef`` **std::size_t**.
``std::size_t`` is the unsigned integer type resulting from the ``sizeof`` operator.
``std::size_t`` represents the maximum number of bytes
that can be stored for an object of any type (including array).

This means that ``std::size_t`` is **guaranteed** to always be big enough to use safely
as an index in any array.
This doesn't mean you can't access an invalid element of an array,
only that the index can be increased without worrying about the index
variable overflowing (see the previous discussion about overflow).

The purpose of ``size_t`` is to relieve the programmer from having 
to worry about which of the predefined unsigned types is used to represent sizes.

Code that assumes ``sizeof`` yields an ``unsigned int`` is not as portable 
as code that assumes it yields a ``size_t``.

``std::size_t`` is commonly used for array indexing and loop counting. 
Programs that use other types, such as ``unsigned int``, 
for array indexing may fail, for example, 
on 64-bit systems when the index exceeds ``UINT_MAX`` or 
if it relies on 32-bit modular arithmetic.

So, if you must write a hand-rolled loop to loop though a container that returns its size,
then prefer this:

.. code-block:: cpp
 
   for (std::size_t i = 0; i < foo.size(); ++i) 

over this:

.. code-block:: cpp

   for (int i = 0; i < foo.size(); ++i) 

As a programmer, you need to use caution if the variable ``i`` is to be used for anything
other than an index --- for example, in an arithmetic expression.
Avoid mixing signed and unsigned types as the results can be surprising.
Also be aware that C++ uses signed integers for array subscripts and 
the standard library uses unsigned integers for container subscripts. 
This makes absolute consistency in all situations impossible.

Later on, we will cover techniques that improve on iterating through data even more.

.. admonition:: Try This!

   Run the following program on the active code server, then try running it on buffy.

   .. activecode:: ac-size-type-1
      :language: cpp

      #include <iostream>
      #include <string>

      int main() {
        char c = 'a';
        std::cout << "size of char:         " << sizeof(c) << '\n'
                  << "size of int:          " << sizeof(int) << '\n'
                  << "size of unsigned int: " << sizeof(unsigned) << '\n'
                  << "size of double:       " << sizeof(double) << '\n'
                  << "size of size_t:       " << sizeof(size_t) << '\n'
                  << "size of pointer:      " << sizeof(&c) << std::endl;

        double foo[10] = {0.1, 3.14159, 1e1, 2e-6, 5, 6, 7, 8, 9, 10};
        std::cout << "size of double foo[]:     " << sizeof(foo) << '\n'
                  << "no. of elements in foo[]: " << sizeof(foo) / sizeof(foo[0]) << std::endl;
      }

   What sizes are different?  Why?

   What are the implications of these differences when writing code that needs to run on both?


.. reveal:: reveal-skill-check-types
   :showtitle: Show Skill Check
   :hidetitle: Hide Skill Check

   .. dragndrop:: dnd_type1
      :feedback: Review the summaries above.
      :match_1: Specifying the type and name for a variable|||declaring a variable 
      :match_2: A whole number|||integer
      :match_3: A name associated with a memory location.|||variable
      :match_4: An expression that is either true or false|||bool
        
      Drag the definition from the left and drop it on the correct concept on the right.  Click the "Check Me" button to see if you are correct
        
   .. dragndrop:: dnd_type2
      :feedback: Review the summaries above.
      :match_1: Setting the value of a variable the first time|||initialize
      :match_2: An operator that returns the remainder|||modulous
      :match_3: a type used to represent decimal values|||double
      :match_4: changing the type of a variable|||casting
        
      Drag the definition from the left and drop it on the correct concept on the right.  Click the "Check Me" button to see if you are correct.


-----

.. admonition:: More to Explore

   - `cppreference.com types <http://en.cppreference.com/w/cpp/language/types>`_ and
     `std::size_t <http://en.cppreference.com/w/cpp/types/size_t>`_
   - ISO CPP Super FAQ: `Floating point questions <https://isocpp.org/wiki/faq/newbie#floating-pt-errs>`_
   - `What every computer scientist should know about floating-point arithmetic 
     <http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html>`_
   - `CPP Core Guidelines: Arithmetic <https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#arithmetic>`_
   - An interesting alternative to explore, Google Protocol Buffers use
     variable length `zig-zag encoding <https://developers.google.com/protocol-buffers/docs/encoding?csw=1>`_
   - `Secure Coding in C++: Integers <https://resources.sei.cmu.edu/asset_files/Presentation/2011_017_001_51345.pdf>`_


.. topic:: Footnotes

   .. [Aspnes2014] Adapted from `The IEEE-754 floating-point standard (PineWiki) <http://www.cs.yale.edu/homes/aspnes/pinewiki/C(2f)FloatingPoint.html>`_ and `Class 223 notes <http://www.cs.yale.edu/homes/aspnes/classes/223/notes.pdf>`_ page 101. Retrieved 2017-06-09.


